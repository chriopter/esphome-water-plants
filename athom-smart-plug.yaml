################################################
# ATHOM SMART PLUG V3 BASE CONFIGURATION
################################################
# This section loads the standard Athom Smart Plug package
# which includes: relay control, power monitoring, physical button, LED, etc.

packages:
  Athom_Technology.Smart_Plug_V3: github://athom-tech/esp32-configs/athom-smart-plug.yaml


################################################
# SCHEDULER ADDON - CONFIGURATION
################################################
# Everything below this line adds scheduling functionality to the smart plug

esphome:
  name: athom-smart-plug-scheduler
  friendly_name: Smart Plug with Scheduler
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // Initialize morning time text field from saved values
          char morning_time[6];
          sprintf(morning_time, "%02d:%02d", id(morning_hour), id(morning_minute));
          id(morning_time_text).publish_state(morning_time);
          
          // Initialize evening time text field from saved values
          char evening_time[6];
          sprintf(evening_time, "%02d:%02d", id(evening_hour), id(evening_minute));
          id(evening_time_text).publish_state(evening_time);
          
          ESP_LOGI("scheduler", "Initialized time fields: Morning %s, Evening %s", 
                   morning_time, evening_time);


################################################
# SCHEDULER ADDON - SAFETY SYSTEMS  
################################################
# Independent watchdog timer to ensure plug turns off even if scripts fail
# Note: This is moved to the time platform to avoid conflicts with the package


################################################
# SCHEDULER ADDON - PERSISTENT STORAGE
################################################
# Global variables to store schedule settings between reboots

globals:
  # Duration in minutes
  - id: action_duration
    type: float
    restore_value: true
    initial_value: '5.0'
  # Morning schedule time
  - id: morning_hour
    type: int
    restore_value: true
    initial_value: '7'
  - id: morning_minute
    type: int
    restore_value: true
    initial_value: '0'
  # Evening schedule time
  - id: evening_hour
    type: int
    restore_value: true
    initial_value: '19'
  - id: evening_minute
    type: int
    restore_value: true
    initial_value: '0'
  # Schedule enable flags
  - id: morning_enabled
    type: bool
    restore_value: true
    initial_value: 'true'
  - id: evening_enabled
    type: bool
    restore_value: true
    initial_value: 'true'
  # Currently active flag and remaining time
  - id: is_active
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: action_end_time
    type: int
    restore_value: false
    initial_value: '0'
  - id: should_stop_action
    type: bool
    restore_value: false
    initial_value: 'false'
  # Absolute maximum timeout (safety feature)
  - id: max_action_timeout
    type: int
    restore_value: false
    initial_value: '600'  # 10 minutes absolute maximum


################################################
# SCHEDULER ADDON - MANUAL TIMER CONTROLS
################################################
# Buttons for manual timer control (separate from physical button)

button:
  # Manual start button
  - platform: template
    name: "Pump Start Manual Timer"
    icon: "mdi:play"
    entity_category: "config"
    on_press:
      then:
        - script.execute: start_scheduled_action
  # Stop button
  - platform: template
    name: "Pump Stop Timer"
    icon: "mdi:stop"
    entity_category: "config"
    on_press:
      then:
        - lambda: |-
            // Signal the script to stop by setting the flag
            id(should_stop_action) = true;
            // Also immediately update state to allow manual restart
            id(is_active) = false;
            id(action_end_time) = 0;
            ESP_LOGD("scheduler", "Timer stopped manually");
        - switch.turn_off: relay


################################################
# SCHEDULER ADDON - TIMER DURATION CONTROL
################################################

number:
  - platform: template
    name: "Pump Timer Duration"
    id: duration_slider
    optimistic: true
    min_value: 1
    max_value: 30
    step: 1
    unit_of_measurement: "min"
    icon: "mdi:timer"
    restore_value: true
    initial_value: 5
    entity_category: "config"
    set_action:
      then:
        - globals.set:
            id: action_duration
            value: !lambda 'return x;'


################################################
# SCHEDULER ADDON - SCHEDULE TIME INPUTS
################################################

text:
  - platform: template
    name: "Pump Morning Schedule Time"
    id: morning_time_text
    optimistic: true
    icon: "mdi:clock-time-eight"
    restore_value: true
    initial_value: "07:00"
    min_length: 5
    max_length: 5
    mode: text
    pattern: "^([01]?[0-9]|2[0-3]):[0-5][0-9]$"  # HH:MM format validation
    entity_category: "config"
    on_value:
      then:
        - lambda: |-
            std::string time_str = id(morning_time_text).state;
            if (time_str.length() == 5 && time_str[2] == ':') {
              int hour = atoi(time_str.substr(0, 2).c_str());
              int minute = atoi(time_str.substr(3, 2).c_str());
              
              if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
                id(morning_hour) = hour;
                id(morning_minute) = minute;
                ESP_LOGD("scheduler", "Morning time set to %02d:%02d", hour, minute);
              }
            }

  - platform: template
    name: "Pump Evening Schedule Time"
    id: evening_time_text
    optimistic: true
    icon: "mdi:clock-time-six"
    restore_value: true
    initial_value: "19:00"
    min_length: 5
    max_length: 5
    mode: text
    pattern: "^([01]?[0-9]|2[0-3]):[0-5][0-9]$"  # HH:MM format validation
    entity_category: "config"
    on_value:
      then:
        - lambda: |-
            std::string time_str = id(evening_time_text).state;
            if (time_str.length() == 5 && time_str[2] == ':') {
              int hour = atoi(time_str.substr(0, 2).c_str());
              int minute = atoi(time_str.substr(3, 2).c_str());
              
              if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
                id(evening_hour) = hour;
                id(evening_minute) = minute;
                ESP_LOGD("scheduler", "Evening time set to %02d:%02d", hour, minute);
              }
            }


################################################
# SCHEDULER ADDON - SCHEDULE ENABLE SWITCHES
################################################

switch:
  - platform: template
    name: "Pump Morning Schedule Enabled"
    id: morning_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: "config"
    icon: "mdi:weather-sunset-up"
    turn_on_action:
      - globals.set:
          id: morning_enabled
          value: 'true'
    turn_off_action:
      - globals.set:
          id: morning_enabled
          value: 'false'
    lambda: |-
      return id(morning_enabled);

  - platform: template
    name: "Pump Evening Schedule Enabled"
    id: evening_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: "config"
    icon: "mdi:weather-sunset-down"
    turn_on_action:
      - globals.set:
          id: evening_enabled
          value: 'true'
    turn_off_action:
      - globals.set:
          id: evening_enabled
          value: 'false'
    lambda: |-
      return id(evening_enabled);


################################################
# SCHEDULER ADDON - STATUS SENSORS
################################################

sensor:
  # Timer remaining time in minutes (for compatibility)
  - platform: template
    name: "Pump Timer Remaining Minutes"
    id: remaining_minutes
    unit_of_measurement: "min"
    icon: "mdi:timer-outline"
    update_interval: 1s
    entity_category: "diagnostic"
    accuracy_decimals: 1
    lambda: |-
      if (!id(is_active)) {
        return 0;
      }
      int remaining_seconds = id(action_end_time) - millis()/1000;
      if (remaining_seconds <= 0) {
        return 0;
      }
      return remaining_seconds / 60.0;
  
  # Timer remaining time in seconds
  - platform: template
    name: "Pump Timer Remaining Seconds"
    id: remaining_seconds_sensor
    unit_of_measurement: "s"
    icon: "mdi:timer-sand"
    update_interval: 1s
    entity_category: "diagnostic"
    lambda: |-
      if (!id(is_active)) {
        return 0;
      }
      int remaining_seconds = id(action_end_time) - millis()/1000;
      if (remaining_seconds <= 0) {
        return 0;
      }
      return remaining_seconds;

text_sensor:
  # Timer remaining time as MM:SS format
  - platform: template
    name: "Pump Timer Remaining Time"
    id: remaining_time_text
    icon: "mdi:timer"
    update_interval: 1s
    entity_category: "diagnostic"
    lambda: |-
      if (!id(is_active)) {
        return std::string("0:00");
      }
      int total_seconds = id(action_end_time) - millis()/1000;
      if (total_seconds <= 0) {
        return std::string("0:00");
      }
      int minutes = total_seconds / 60;
      int seconds = total_seconds % 60;
      char buffer[16];
      sprintf(buffer, "%d:%02d", minutes, seconds);
      return std::string(buffer);
  
  - platform: template
    name: "Pump Next Scheduled Action"
    id: next_scheduled_action
    update_interval: 10s
    icon: "mdi:calendar-clock"
    entity_category: "diagnostic"
    lambda: |-
      auto now = id(esptime).now();
      if (!now.is_valid()) {
        return std::string("Unknown - time not set");
      }
      
      // Convert all times to minutes-since-midnight for easier comparison
      int now_minutes = now.hour * 60 + now.minute;
      int timer1_minutes = id(morning_hour) * 60 + id(morning_minute);
      int timer2_minutes = id(evening_hour) * 60 + id(evening_minute);
      
      // Calculate minutes until next action for both timers
      int minutes_until_timer1 = timer1_minutes - now_minutes;
      if (minutes_until_timer1 <= 0) {
        minutes_until_timer1 += 24 * 60; // Add a day if it's already passed
      }
      
      int minutes_until_timer2 = timer2_minutes - now_minutes;
      if (minutes_until_timer2 <= 0) {
        minutes_until_timer2 += 24 * 60; // Add a day if it's already passed
      }
      
      // Determine which timer comes next
      if (!id(morning_enabled) && !id(evening_enabled)) {
        return std::string("No schedule active");
      } else if (!id(morning_enabled)) {
        // Only evening timer is enabled
        std::string result = (minutes_until_timer2 > 12 * 60) ? "Tomorrow " : "Today ";
        result += std::to_string(id(evening_hour)) + ":";
        if (id(evening_minute) < 10)
          result += "0";
        result += std::to_string(id(evening_minute));
        return result;
      } else if (!id(evening_enabled)) {
        // Only morning timer is enabled
        std::string result = (minutes_until_timer1 > 12 * 60) ? "Tomorrow " : "Today ";
        result += std::to_string(id(morning_hour)) + ":";
        if (id(morning_minute) < 10)
          result += "0";
        result += std::to_string(id(morning_minute));
        return result;
      } else {
        // Both timers are enabled - show whichever comes first
        if (minutes_until_timer1 <= minutes_until_timer2) {
          std::string result = (minutes_until_timer1 > 12 * 60) ? "Tomorrow " : "Today ";
          result += std::to_string(id(morning_hour)) + ":";
          if (id(morning_minute) < 10)
            result += "0";
          result += std::to_string(id(morning_minute));
          return result;
        } else {
          std::string result = (minutes_until_timer2 > 12 * 60) ? "Tomorrow " : "Today ";
          result += std::to_string(id(evening_hour)) + ":";
          if (id(evening_minute) < 10)
            result += "0";
          result += std::to_string(id(evening_minute));
          return result;
        }
      }


################################################
# SCHEDULER ADDON - TIME MANAGEMENT
################################################

time:
  - platform: homeassistant
    id: esptime
    on_time_sync:
      # Update the next scheduled time immediately when time becomes available
      then:
        - logger.log: "Time synchronized, updating schedule displays"
        - component.update: next_scheduled_action
    on_time:
      # Watchdog timer - check every 2 seconds for safety
      - seconds: /2
        then:
          - lambda: |-
              // Independent safety system that runs every 2 seconds
              if (id(is_active)) {
                uint32_t now = millis()/1000;
                int remaining_seconds = id(action_end_time) - now;
                
                // If time has run out but plug is still on
                if (remaining_seconds <= 0) {
                  ESP_LOGE("scheduler", "ðŸ”¥ WATCHDOG TIMER EMERGENCY SHUTDOWN!");
                  id(relay).turn_off();
                  id(is_active) = false;
                }
              }
      
      # Check every minute if action should start
      - seconds: 0
        minutes: /1
        then:
          - lambda: |-
              auto time = id(esptime).now();
              if (time.is_valid()) {
                int now_hour = time.hour;
                int now_minute = time.minute;
                
                // Check morning schedule
                if (id(morning_enabled) && now_hour == id(morning_hour) && now_minute == id(morning_minute) && !id(is_active)) {
                  ESP_LOGD("scheduler", "Starting morning scheduled action");
                  id(start_scheduled_action).execute();
                }
                
                // Check evening schedule
                if (id(evening_enabled) && now_hour == id(evening_hour) && now_minute == id(evening_minute) && !id(is_active)) {
                  ESP_LOGD("scheduler", "Starting evening scheduled action");
                  id(start_scheduled_action).execute();
                }
              }
              
              // EMERGENCY BACKUP CHECK for plug shutdown
              // This is an independent safety check that runs every minute
              // to ensure plug gets turned off if the normal check fails
              if (id(is_active)) {
                uint32_t now = millis()/1000;
                int time_left = id(action_end_time) - now;
                
                if (time_left <= 0) {
                  ESP_LOGW("scheduler", "âš ï¸ EMERGENCY TIMED BACKUP SHUTDOWN!");
                  id(relay).turn_off();
                  id(is_active) = false;
                }
              }


################################################
# SCHEDULER ADDON - AUTOMATION SCRIPTS
################################################

script:
  - id: start_scheduled_action
    then:
      - lambda: |-
          // Mark the action as started and schedule end time
          id(is_active) = true;
          id(action_end_time) = millis()/1000 + (id(action_duration) * 60);
          id(should_stop_action) = false;
          
          // Set absolute safety timeout (duration + 1 minute)
          id(max_action_timeout) = millis()/1000 + (id(action_duration) * 60) + 60;
          
          ESP_LOGD("scheduler", "Starting scheduled action for %0.1f minutes", (float)id(action_duration));
      - switch.turn_on: relay
      # Start a short interval check instead of a single long delay
      - script.execute: check_action_status
  
  # This script runs periodically during active timer to check if it should continue or be stopped
  - id: check_action_status
    then:
      # CRITICAL: First thing - check if we need to stop, and IMMEDIATELY turn off the plug if needed
      - if:
          condition:
            lambda: |-
              uint32_t now = millis()/1000;
              int time_left = id(action_end_time) - now;
              bool timeout_reached = (time_left <= 0);
              bool safety_timeout = (now >= id(max_action_timeout));
              
              // Log state for debugging
              ESP_LOGI("scheduler_check", "CRITICAL CHECK: time_left=%d, is_active=%d, should_stop=%d, safety=%d", 
                       time_left, id(is_active), id(should_stop_action), safety_timeout);
                       
              // Return true if ANY condition indicates we should stop
              return timeout_reached || !id(is_active) || id(should_stop_action) || safety_timeout;
          then:
            # PLUG OFF - these conditions always turn the plug off immediately
            - logger.log: "EMERGENCY PLUG SHUTDOWN TRIGGERED!"
            - switch.turn_off: relay
            - delay: 100ms  # Tiny delay to ensure the relay command is processed
            - lambda: |-
                // Reset all state
                id(is_active) = false;
                id(should_stop_action) = false;
                ESP_LOGW("scheduler", "âš ï¸ Timer FORCE stopped - end time reached or manual stop requested");
          else:
            # Continue timer and monitoring
            - lambda: |-
                // Get current time and calculate remaining time
                uint32_t current_time = millis()/1000;
                int remaining_seconds = id(action_end_time) - current_time;
                ESP_LOGD("scheduler", "âœ“ Timer continues - %d seconds remaining", remaining_seconds);
                
                // Make sure plug is on (failsafe in case it was turned off)
                if (id(is_active) && remaining_seconds > 0) {
                  ESP_LOGD("scheduler", "Plug should be ON");
                }
      
      # Decide whether to keep monitoring or stop the script
      - if:
          condition:
            lambda: 'return id(is_active);'
          then:
            # Set a shorter check interval for more responsive stopping
            - delay: 1s
            - script.execute: check_action_status